<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc PUBLIC "-//IETF//DTD RFC 2629//EN" "http://xml.resource.org/authoring/rfc2629.dtd" [
  <!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY rfc2617 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml">
  <!ENTITY rfc3230 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3230.xml">
  <!ENTITY rfc4648 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
  <!ENTITY rfc5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
  <!ENTITY rfc6376 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6376.xml">
  <!ENTITY rfc6749 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6749.xml">
  <!ENTITY httpbis-p1 SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p1-messaging-25.xml">
  <!ENTITY httpbis-p7 SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p7-auth-25.xml">
  <!ENTITY jwa SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-jose-json-web-algorithms-20.xml">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xsl" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc toc="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc symrefs="yes" ?>
<rfc category="std" ipr="trust200902" submissionType="independent" 
     docName="draft-cavage-http-signatures-02">
<front>
 <title>The 'Signature' HTTP Authentication Scheme</title>

 <author initials="M.C." surname="Cavage" fullname="Mark Cavage">
  <organization>Joyent</organization>
  <address>
   <postal>
    <street>One Embarcadero Center</street>
    <street>9th Floor</street>
    <city>San Francisco</city> <region>CA</region>
    <code>94111</code>
    <country>US</country>
   </postal>
   <phone>+1 415 400 0626 </phone>
   <email>mark.cavage@joyent.com</email>
   <uri>http://www.joyent.com/</uri>
  </address>
 </author>

 <author initials="M.S." surname="Sporny" fullname="Manu Sporny">
  <organization>Digital Bazaar</organization>
  <address>
   <postal>
    <street>1700 Kraft Drive</street>
    <street>Suite 2408</street>
    <city>Blacksburg</city> <region>VA</region>
    <code>24060</code>
    <country>US</country>
   </postal>
   <phone>+1 540 961 4469</phone>
   <email>msporny@digitalbazaar.com</email>
   <uri>http://manu.sporny.org/</uri>
  </address>
 </author>

 <date month="February" year="2014" />
 <area>Security</area>
 <workgroup></workgroup>
 <keyword>HTTP</keyword>
 <keyword>digital signature</keyword>
 <keyword>PKI</keyword>
 <abstract>
  <t>
When communicating over the Internet using the HTTP protocol, it can be
desirable for a server to authenticate the client that sent a message.
It can also be desirable to ensure that the message was not tampered with 
during transit. This document describes a way for clients to
simultaneously add authentication and message integrity to HTTP messages by
using a digital signature.
  </t>
 </abstract>
 <note title="Feedback">
  <t>
This specification is a part of the 
<eref target="https://web-payments.org/">Web Payments</eref> work. Feedback 
related to this specification should be sent to
<eref target="mailto:public-webpayments@w3.org">public-webpayments@w3.org</eref>.
  </t>
 </note>
</front>

<middle>

 <section anchor="intro" title="Introduction">
  <t>
This protocol extension is intended to provide a standard way for clients to 
sign HTTP messages.  <xref target="RFC2617">HTTP Authentication</xref> 
defines Basic and Digest authentication mechanisms, and 
<xref target="RFC5246">TLS 1.2</xref>
defines client-auth, both of which are widely
employed on the Internet today.  The burdens of PKI prevent some
web service operators from deploying that methodoloy, and so some of those
organizations fall back to Basic or Digest authentication. Basic and
Digest authentication provide poor security characteristics when combined 
with common password usage behavior. 
  </t>

  <t>
Password database compromises between 2010 to 2014 have shown that people 
regularly use weak passwords and share the same
password across multiple websites. The use of Basic authentication over a
regular HTTP channel provides no protection. Digest authentication, while 
providing some level of protection, still leaves the scheme open to 
brute-force attacks that are capable of discovering a weak or random 8 character 
password in less than 3 hours using a single commodity computer and mere 
minutes using cloud-based rental servers to distribute the brute-force attack.
  </t>

  <t>
While it is true that most Basic and Digest authentication approaches are 
operated over secure channels like TLS, revelations over pervasive monitoring 
in 2012 have shown that TLS may not be secure enough to protect sensitive data.
  </t>

  <t>
Additionally, <xref target="RFC6749">OAuth 2.0</xref> provides a 
fully-specified alternative for authorization of web service requests, but is 
not always ideal for machine to machine communication, as the key acquisition 
steps generally imply a fixed infrastructure that may not make sense to a 
service provider. For example, the use of symmetric keys and the distribution
of hundreds of thousands of those keys across multiple datacenters around the
world create multiple points of attack where a successful attack results in
a large gain for the attacker and thus an even bigger problem for the service 
provider and their customers.
  </t>

  <t>
Several web service providers have invented their own schemes for signing
HTTP requests, but to date, none have been standardized.  This document serves 
that purpose.  There are no techniques in this proposal that are novel beyond 
previous art, however, this aims to be a simple mechanism for signing these 
messages.
  </t> 
 
 </section>
 
 <section anchor="auth" title="Signature Authentication Scheme">

  <t>
The "signature" authentication scheme is based on the model that the client must
authenticate itself with a digital signature produced by either a private
asymmetric key (e.g., RSA) or a shared symmetric key (e.g., HMAC).  The scheme
is parameterized enough such that it is not bound to any particular key type or
signing algorithm.  However, it does explicitly assume that clients can send an
HTTP `Date` header.
  </t>
  
  <section anchor="header" title="Authorization Header">

   <t>
The client is expected to send an Authorization header 
(as defined in 
<xref target="I-D.ietf-httpbis-p7-auth">HTTPbis 1.1, Part 7</xref>, <eref 
target="http://tools.ietf.org/html/draft-ietf-httpbis-p7-auth-25#section-4.1">
Section 4.1</eref>) where the "auth-scheme" is "Signature" and the 
"auth-param" parameters meet the requirements listed below:
   </t>

   <section anchor="params" title="Signature Parameters">

    <t>
The following section details the signature parameters of the Authorization
Header.
    </t>

    <section anchor="keyId" title="keyId">
     <t>
REQUIRED.  The `keyId` field is an opaque string that the server can use to look
up the component they need to validate the signature.  It could be an SSH key
fingerprint, an LDAP DN, etc.  Management of keys and assignment of `keyId` is
out of scope for this document.
     </t>
    </section>
    
    <section anchor="algorithm" title="algorithm">

     <t>
REQUIRED. The `algorithm` parameter is used to specify the digital signature
algorithm to use when generating the signature. Valid values for this
parameter can be found in the Signature Algorithms registry located at 
<eref target="http://www.iana.org/assignments/signature-algorithms">
http://www.iana.org/assignments/signature-algorithms</eref> and MUST NOT be
marked "deprecated".
     </t>
    </section>
    
    <section anchor="headers" title="headers">

     <t>
OPTIONAL.  The `headers` parameter is used to specify the list of HTTP headers
used to sign the request.  If specified, it should be a lowercased,
quoted list of HTTP header fields, separated by a single space character.  
By default, only one HTTP header is signed, which is the `Date` header.  
Note that the list order is important, and MUST be specified in the order 
the values are concatenated together during signing. 
     </t>
    </section>
    
    <section anchor="signature" title="signature">
     <t>
REQUIRED.  The `signature` parameter is a base 64 encoded digital signature,
as described in <xref target="RFC4648">RFC 4648</xref>, 
<eref target="http://tools.ietf.org/html/rfc4648#section-4">Section 4</eref>.
The client uses the `algorithm` and `headers` request parameters to form a 
canonicalized `signing string`.  This `signing string` is then signed with the 
key associated with `keyId` and the algorithm corresponding to `algorithm`.
The `signature` parameter is then set to the base 64 encoding of the signature.
     </t>
    </section>
   </section>

   <section anchor="ambiguity" title="Ambiguous Parameters">
    <t>
If any of the Signature scheme parameter names are erroneously duplicated in the 
Authorization header field, then the last parameter defined MUST be used. Any
parameter that is not recognized as a Signature scheme parameter, or is
not well-formed, MUST be ignored.
    </t>
   </section>
   
   <section anchor="canonicalization" title="Signature String Construction">
   
   <t>
In order to generate the string that is signed with a key, the client MUST use
the values of each HTTP header field specified by `headers` in the order they 
appear. It is out of scope for this document to dictate what header fields 
an application will want to enforce, but implementers SHOULD at minimum 
include the method + URL (request-line), Host, and Date header fields.
   </t>
   <t>
To include the HTTP request line in the signature calculation, use the 
special `(request-line)` header field name.
    <list style="numbers">
     <t>
If the header field name is `(request-line)` then generate the header field 
value by concatenating the lowercased method name, an ASCII space, and the 
method URL.
     </t>
     <t>
Create the header field string by concatenating the lowercased header field 
name followed with an ASCII colon `:`, an ASCII space ` `, and the header 
field value. The value MUST NOT be modified or canonicalized in any way. If 
there are multiple instances of the same header field, all header field values 
associated with the header field MUST be concatenated and used in the order in 
which they will appear in the transmitted HTTP message.
     </t>
     <t>
If value is not the last value then append an ASCII newline `\n`.
     </t>
    </list>
   </t>   
   <t>
The rest of this section uses the following HTTP request as an example.

    <figure>
     <artwork>
POST /foo HTTP/1.1
Host: example.org
Date: Tue, 07 Jun 2014 20:51:35 GMT
Content-Type: application/json
Digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
Content-Length: 18

{"hello": "world"}
     </artwork>
    </figure>
   </t>
   
   <t>
Note that the use of the `Digest` header field is per 
<xref target="RFC3230">RFC 3230</xref>, <eref 
target="http://tools.ietf.org/html/rfc3230#section-4.3.2">Section 4.3.2</eref>
and is included merely as a demonstration of how an implementer could include 
information about the body of the message in the signature.
The following sections also assume that the "rsa-key-1" keyId refers to a 
private key known to the client and a public key known to the server. 
The "hmac-key-1" keyId refers to key known to the client and server.
   </t>
   
   <section anchor="rsa-example" title="RSA Example">
   
   <t>
The authorization header and signature would be generated as:
    <figure>
     <artwork>
Authorization: Signature keyId="rsa-key-1",algorithm="rsa-sha256",
headers="(request-line) host date digest content-length",
signature="Base64(RSA-SHA256(signing string))"
     </artwork>
    </figure>
   </t>
   
   <t>
The client would compose the signing string as:
    <figure>
     <artwork>
(request-line): post /foo\n
host: example.org\n
date: Tue, 07 Jun 2014 20:51:35 GMT\n
digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=\n
content-length: 18
     </artwork>
    </figure>
Note that the '\n' symbols above are included to demonstrate where the new 
line character should be inserted. There is no new line on the final line of
the signing string.
   </t>

   <t>
For an RSA-based signature, the authorization header and signature would then
be generated as:
    <figure>
     <artwork>
Authorization: Signature keyId="rsa-key-1",algorithm="rsa-sha256",
headers="(request-line) host date digest content-length",
signature="Base64(RSA-SHA256(signing string))"
     </artwork>
    </figure>
   </t>
  </section>
  
  <section anchor="hmac-example" title="HMAC Example">

   <t>
For an HMAC-based signature without a list of headers specified, the 
authorization header and signature would be generated as:
    <figure>
     <artwork>
Authorization: Signature keyId="hmac-key-1",algorithm="hmac-sha256",
headers="(request-line) host date digest content-length",
signature="Base64(HMAC-SHA256(signing string))"
     </artwork>
    </figure>
   </t>

   <t>
The only difference between the RSA Example and the HMAC Example is the
signature algorithm that is used. The client would compose the signing string 
in the same way as the RSA Example above:
    <figure>
     <artwork>
(request-line): post /foo\n
host: example.org\n
date: Tue, 07 Jun 2014 20:51:35 GMT\n
digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=\n
content-length: 18
     </artwork>
    </figure>
   </t>

    </section>
   </section>
  </section>

 </section>
</middle>
<back>
 <references title="Normative References">
  &rfc2119;
  &rfc4648;
  &rfc6376;
  &httpbis-p1;
  &httpbis-p7;
  &jwa;
 </references>
 <references title="Informative References">
  &rfc2617;
  &rfc3230;
  &rfc5246;
  &rfc6749;
 </references>

 <section anchor="appendix-a" title="Security Considerations">
  <t>
There are a number of security considerations to take into account when implementing
or utilizing this specification. A thorough security analysis of this protocol,
including its strengths and weaknesses, can be found in 
<eref target="https://web-payments.org/specs/source/http-signatures-audit/">
Security Considerations for HTTP Signatures</eref>.
  </t>
 </section>

 <section anchor="appendix-b" title="Extensions">
  <t>
This specification was designed to be simple, modular, and extensible. There
are a number of other specifications that build on this one. For
example, the 
<eref target="https://web-payments.org/specs/source/http-signature-nonces/">HTTP Signature Nonces</eref>
specification details how to
use HTTP Signatures over a non-secured channel like HTTP and the 
<eref target="https://web-payments.org/specs/source/http-signature-trailers/">HTTP Signature Trailers</eref>
specification explains how to apply HTTP
Signatures to streaming content. Developers that desire more functionality
than this specification provides are urged to ensure that an extension
specification doesn't already exist before implementing a proprietary 
extension.
  </t>

  <t>
If extensions to this specification are made by adding new Signature
Parameters, those extension parameters MUST be registered in the
Signature Authentication Scheme Registry. The registry will be created and 
maintained at (the suggested URI) 
<eref target="http://www.iana.org/assignments/http-auth-scheme-signature">
http://www.iana.org/assignments/http-auth-scheme-signature</eref>. An 
example entry in this registry is included below:

   <figure>
    <artwork>
Signature Parameter: nonce
Reference to specification: [HTTP_AUTH_SIGNATURE_NONCE], Section XYZ.
Notes (optional): The HTTP Signature Nonces specification details how to use 
  HTTP Signatures over a unsecured channel like HTTP.
    </artwork>
   </figure>
  </t>
 </section>

 <section anchor="appendix-c" title="Test Values">
  <t>
The following test data uses the following RSA 2048-bit keys, which we will 
refer to as `keyId=Test` in the following samples:

   <figure>
    <artwork>
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCFENGw33yGihy92pDjZQhl0C3
6rPJj+CvfSC8+q28hxA161QFNUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6
Z4UMR7EOcpfdUE9Hf3m/hs+FUR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJw
oYi+1hqp1fIekaxsyQIDAQAB
-----END PUBLIC KEY-----
    </artwork>
   </figure>

   <figure>
    <artwork>
-----BEGIN RSA PRIVATE KEY-----
MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF
NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F
UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB
AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA
QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK
kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg
f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u
412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc
mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7
kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA
gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW
G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI
7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==
-----END RSA PRIVATE KEY-----
    </artwork>
   </figure>
  </t>

  <t>
All examples use this request:
   <figure>
    <artwork>
POST /foo?param=value&amp;pet=dog HTTP/1.1
Host: example.com
Date: Thu, 05 Jan 2014 21:31:40 GMT
Content-Type: application/json
Digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
Content-Length: 18

{"hello": "world"}
    </artwork>
   </figure>
  </t>

  <section anchor="default-test" title="Default Test">
   <t>
If a list of headers is not included, the date is the only header that is
signed by default. The string to sign would be:
    <figure>
     <artwork>
date: Thu, 05 Jan 2014 21:31:40 GMT
    </artwork>
   </figure>
   </t>
   
   <t>
The Authorization header would be:
    <figure>
     <artwork>
Authorization: Signature keyId="Test",algorithm="rsa-sha256",
signature="ATp0r26dbMIxOopqw0OfABDT7CKMIoENumuruOtarj8n/97Q3htH
FYpH8yOSQk3Z5zh8UxUym6FYTb5+A0Nz3NRsXJibnYi7brE/4tx5But9kkFGzG+
xpUmimN4c3TMN7OFH//+r8hBf7BT9/GmHDUVZT2JzWGLZES2xDOUuMtA="
    </artwork>
   </figure>
   </t>
  </section>

  <section anchor="basic-test" title="Basic Test">
   <t>
The minimum recommended data to sign is the (request-line), host, and date. In
this case, the string to sign would be:
    <figure>
     <artwork>
(request-line): post /foo?param=value&amp;pet=dog
host: example.com
date: Thu, 05 Jan 2014 21:31:40 GMT
    </artwork>
   </figure>
   </t>
   
   <t>
The Authorization header would be:
    <figure>
     <artwork>
Authorization: Signature keyId="Test",algorithm="rsa-sha256",
headers="(request-line) host date", signature="KcLSABBj/m3v2Dhxi
CKJmzYJvnx74tDO1SaURD8Dr8XpugN5wpy8iBVJtpkHUIp4qBYpzx2QvD16t8X
0BUMiKc53Age+baQFWwb2iYYJzvuUL+krrl/Q7H6fPBADBsHqEZ7IE8rR0Ys3l
b7J5A6VB9J/4yVTRiBcxTypW/mpr5w="
    </artwork>
   </figure>
   </t>
  </section>
  
  <section anchor="all-headers-test" title="All Headers Test">
   <t>
A strong signature including all of the headers and a digest of the body of
the HTTP request would result in the following signing string:
    <figure>
     <artwork>
(request-line): post /foo?param=value&amp;pet=dog
host: example.com
date: Thu, 05 Jan 2014 21:31:40 GMT
content-type: application/json
digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
content-length: 18
     </artwork>
    </figure>
   </t>
   
   <t>
The Authorization header would be:
    <figure>
     <artwork>
Authorization: Signature keyId="Test",algorithm="rsa-sha256",
headers="(request-line) host date content-type digest content-length",
signature="jgSqYK0yKclIHfF9zdApVEbDp5eqj8C4i4X76pE+XHoxugXv7q
nVrGR+30bmBgtpR39I4utq17s9ghz/2QFVxlnToYAvbSVZJ9ulLd1HQBugO0j
Oyn9sXOtcN7uNHBjqNCqUsnt0sw/cJA6B6nJZpyNqNyAXKdxZZItOuhIs78w="
     </artwork>
    </figure>
   </t>
 </section>
 </section>
 <section anchor="acknowledgements" title="Acknowledgements">
  <t>
The editor would like to thank the following individuals for feedback on and
implementations of the specification (in alphabetical order): Stephen Farrell, 
Phillip Hallam-Baker, Dave Lehn, Dave Longley, James H. Manger, 
Mark Nottingham, Yoav Nir, Julian Reschke, and Michael Richardson.
  </t>
 </section>
 <section anchor="appendix-d" title="IANA Considerations">
  <section anchor="iana-scheme" title="Signature Authentication Scheme">
   <t>
The following entry should be added to the Authentication Scheme Registry
located at <eref target="http://www.iana.org/assignments/http-authschemes">
http://www.iana.org/assignments/http-authschemes</eref>
   </t>
   <t>
Authentication Scheme Name: Signature<vspace/>
Reference: [RFC_THIS_DOCUMENT], Section 2.<vspace/>
Notes (optional): The Signature scheme is designed for clients to 
authenticate themselves with a server. 
   </t>
  </section>
  <section anchor="sa-registry" title="Signature Algorithm Registry">
   <t>
The following initial entries should be added to the Signature Algorithm 
Registry to be created and maintained at (the suggested URI) 
<eref target="http://www.iana.org/assignments/signature-algorithms">
http://www.iana.org/assignments/signature-algorithms</eref>:
   </t>
   <t>
Editor's note: The references in this section are problematic as many of the 
specifications that they refer to are too implementation specific, rather 
than just pointing to the proper signature and hashing specifications. A
better approach might be just specifying the signature and hashing function
specifications, leaving implementers to connect the dots (which are not that
hard to connect).
   </t>
   <t>
Algorithm Name: rsa-sha1<vspace/>
Reference: <xref target="RFC6376">RFC 6376</xref>, Section 3.3.1<vspace/>
Status: deprecated
   </t>
   <t>
Algorithm Name: rsa-sha256<vspace/>
Reference: <xref target="RFC6376">RFC 6376</xref>, Section 3.3.2<vspace/>
Status: active
   </t>
   <t>
Algorithm Name: hmac-sha256<vspace/>
Reference: HS256 in <xref target="I-D.ietf-jose-json-web-algorithms">
JOSE JSON Web Algorithms</xref>, Section 3.2<vspace/>
Status: active
   </t>
   <t>
Algorithm Name: ecdsa-sha256<vspace/>
Reference: ES256 in <xref target="I-D.ietf-jose-json-web-algorithms">
JOSE JSON Web Algorithms</xref>, Section 3.4<vspace/>
Status: active
   </t>
  </section>

 </section>
</back>
</rfc>
