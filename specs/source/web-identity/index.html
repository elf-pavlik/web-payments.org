<!DOCTYPE html> 
<html> 
  <head> 
    <title>Web Identity 1.0</title> 
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/> 
    <!-- 
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     --> 
    <link rel="stylesheet" href="spec.css">
    <script src='../../respec-w3c-common.js' class='remove'></script> 
    <script type="text/javascript" class="remove">
    var preProc = {
          apply:  function(c) {

                    // process the document before anything else is done
                    var refs = document.querySelectorAll('adef') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'dfn' ) ;
                        var tit = item.getAttribute('title') ;
                        if (!tit) {
                            tit = con;
                        }
                        sp.className = 'adef' ;
                        sp.title=tit ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    refs = document.querySelectorAll('aref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'aref' ;
                        sp.setAttribute('title', con);
                        sp.innerHTML = '@'+con ;
                        p.replaceChild(sp, item) ;
                    }
                    // local datatype references
                    refs = document.querySelectorAll('ldtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'datatype';
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // external datatype references
                    refs = document.querySelectorAll('dtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'externalDFN';
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now do terms
                    refs = document.querySelectorAll('tdef') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'dfn' ) ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now term references
                    refs = document.querySelectorAll('tref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }

                        var sp = document.createElement( 'a' ) ;
                        var id = item.textContent ;
                        sp.className = 'tref' ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                }
        } ;

      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "CG-DRAFT",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "web-identity",
 
          // if you wish the publication date to be other than today, set this
          // publishDate:  "2009-08-06",
 
          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",
 
          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://payswarm.com/specs/source/web-identity/",
 
          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",
 
          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Manu Sporny", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar, Inc.", companyURL: "http://digitalbazaar.com/" },
          ],
 
          // authors, add as many as you like. 
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.
 
          //authors:  [
          //    { name: "Your Name", url: "http://example.org/",
          //      company: "Your Company", companyURL: "http://example.com/" },
          //],
          
          // name of the WG
          wg:           "W3C Web Payments Community Group",
          
          // URI of the public WG page
          wgURI:        "http://www.w3.org/community/webpayments/",
          
          // name (with the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-webpayments@w3.org",

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "",
          maxTocLevel: 4,
          preProcess: [ preProc ] /*,
          alternateFormats: [ {uri: "diff-20111214.html", label: "diff to previous version"} ],
          */
      };
    </script> 
    <script type="text/javascript" class="remove">
      var oldonload = window.onload;
      window.onload = function() {
        if (oldonload) oldonload();
        prettyPrint();
      };
    </script>
  </head> 
  <body> 
    <section id='abstract'> 
      <p>
An <em>identity</em> is a Linked Data description of a particular entity 
such as a person or organization. This specification describes a mechanism of 
reading and writing to an online Linked Data identity. Linked Data identities
are useful for storing arbitrary information, such as a person's shipping
address, passport information, or age. The data is only accessible 
by authorized applications.
      </p>
    </section>

    <section id='sotd'> 
      <p>
This is a highly experimental specification that is attempting to unify the
work performed in the the Web Payments Community Group, 
the Linked Data community, the WebID Community Group, 
and the Mozilla Persona team. As such, the specification borrows a number of
concepts from each group and attempts to sythesize these concepts into a
solution that would be easily implemented and deployed by Web developers in
order to provide an elegant readable and writable identity mechanism for the
Web.
      </p>
    </section>

    <section>
      <h2>Introduction</h2>
      <p>
An <tdef>identity</tdef> is a set of information that can be used to 
identify a particular entity such as a person, animal, or organization. We 
use identities to access many services throughout our lives. For example,
we use email addresses to identify ourselves to online services, 
driver's licenses to prove that we are capable of operating a motor vehicle,
and government issued passports to travel between countries. It is the goal
of this specification to provide an easy way of expressing all of this
identity information on the Web.
      </p>
      <p>
There are a number of design principles that have gone into the creation of
this specification. The following is a brief list of these requirements:
      </p>
      <ul>
        <li>
It must be decentralized.
        </li>
        <li>
It must support discoverability by using a resolvable address, like a URL 
or email address.
        </li>
        <li>
It must support, with authorization, arbitrary machine-readable information 
being attached to the identity by 3rd parties.
        </li>
        <li>
It must be able to provide both public and private data to external sites, 
based on who is accessing the resource.
        </li>
        <li>
It must provide a secure digital signature and encryption mechanism.
        </li>
      </ul>
      <p>
This specification enables secure, decentralized, discoverable, controlled 
access to arbitrary machine-readable information associated with an identity.
Since each identity has a varying degree of personal information associated 
with it, the specification ensures that a single entity can associate themselves 
with multiple identities. For example, one may want to use one identity to 
access  banking services while another identity could be used to play 
online games.
      </p>
      <p>
In order to store the breadth of information that is typically associated with
an identity, a simple but extensible data model is utilized. 
The specification uses a data storage and expression approach called
<a href="http://www.w3.org/TR/ld-glossary/#linked-data">Linked Data</a>. it
is a way of expressing information on the Web that is both simple and
extensible. Specifically, the Linked Data technology used by this specification 
is JSON-LD [[!JSON-LD]].
      </p>
    </section>

    <section>
      <h2>The Identity</h2>
      <p>
An entity may have one or more identities associated with it. These can be
anonymous identities, pseudo-anonymous identities, protected identities, 
and public identities. The creation of these identities is out of scope
for this document, but typically result in the creation of a long-lived
identity URL. For example, <code>https://example.com/identities/john</code> is
an example of a long-lived identity URL.
      </p>

      <section>
        <h2>A Basic Identity</h2>
        <p>
A basic identity contains at least the type information for the identity.
        <dl>
        <dt><code>@context</code></dt>
        <dd>The value <code>https://w3id.org/identity/v1</code>, or an equivalent
JSON-LD Context [[!JSON-LD]] expressing the terminology necessary for the 
expression of the data.</dd>
        <dt><code>type</code></dt>
        <dd>The value <code>Identity</code>.</dd>
        </p>
      </section>

      <section>
        <h2>A Typical Identity</h2>
        <p>
A typical identity will have a mix of public and private data associated with
it. For example:
        </p>
        
<pre class="example">{
  "@context": "https://w3id.org/identity/v1",
  "id": "https://example.com/identities/bob",
  "type": "Identity",
  "name": "Bob Bobman",
  "shippingAddress": {
    "street": "372 Sumter Lane",
    "city": "Blackrock",
    "region": "Nevada",
    "postalCode": "237842"
  },
  "email": "bbob@example.com",
  "mobileNumber": "4424672637162",
  "citizenship": {
     "assignee": "https://example.com/identities/bob",
     "country": "USA",
     "citizenshipId": "223-93-2422",
     "birthdate": "1985-12-14",
     "name": "BOBULA K. BOBMAN",
     "signature": {
       "type": "GraphSignature2012",
       "signer": "https://ssa.us.gov/keys/27",
       "signature": "3780eyfh3q0fhhfiq3q9f8ahsidfhf29rhaish"
     }
  }
}</pre>
        
      </section>
    </section>
    <section>
      <h1>Accessing the Identity</h1>
      <p>
There are two mechanisms that allow a 3rd party to read protected information
from an identity. The first is an
HTTP Signature [[!HTTP-SIGNATURES]] based mechanism that allows any authorized
client to access data that has been pre-approved by the entity that controls
access to the identity information. The second is to use a browser-based 
mechanism that POSTs a request to an identity, allowing the identity owner to 
interactively decide what data access to allow or disallow.
      </p>

      <p>
The table below summarizes the HTTP Signatures-based [[!HTTP-SIGNATURES]] 
mechanism of accessing and modifying an identity:
      </p>

      <table>
        <thead>
          <tr>
            <th style="white-space: nowrap;">HTTP Method</th>
            <th>Description of Action</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>GET</td>
            <td>
Read all of the information that is available to the requestor. Note: This may 
only be a subset of all of the information based on the level of access the
requestor has to certain attributes in the resource.
            </td>
          </tr>
          <tr>
            <td>POST</td>
            <td>
Used to perform operations on the identity for applications that are not
capable of using HTTP Signatures [[!HTTP-SIGNATURES]] or to perform specific
queries on the identity data.
            </td>
          </tr>
          <tr>
            <td>PATCH</td>
            <td>
Modify information in the identity using the JSON Patch [[!JSON-PATCH]] protocol.
            </td>
          </tr>
          <tr>
            <td>PUT</td>
            <td>
Replace the entire identity with the provided identity document. This operation 
SHOULD only be accessible to the owner of the identity.
            </td>
          </tr>
          <tr>
            <td>DELETE</td>
            <td>
Deletes the identity. This operation SHOULD only be accessible to the owner of 
the identity.
            </td>
          </tr>
        </tbody>
      </table>

      <p class="issue">
It's questionable whether we would want a PUT or DELETE mechanism at all.
      </p>

      <p>
Not every Web application is capable of pre-arranging access to an identity,
performing HTTP Signatures [[!HTTP-SIGNATURES]], or executing 
HTTP PATCH requests. In these cases, a regular HTTP POST mechanism is provided
for Web applications to read, write, and query information about the identity.
      </p>

      <table>
        <thead>
          <tr>
            <th style="white-space: nowrap;">POST Parameter</th>
            <th>Description of Action</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>action=query</td>
            <td>
Performs a query on the identity given a JSON-LD Frame in the POST body.
            </td>
          </tr>
          <tr>
            <td>action=patch</td>
            <td>
Modify information in the identity using the JSON Patch [[!JSON-PATCH]] protocol.
            </td>
          </tr>
        </tbody>
      </table>

      <section>
        <h2>Writing Data to the Identity</h2>
        <p>
JSON-LD data in the body of the request is written to the identity by 
performing an HTTP POST call with a query
parameter called <code>action</code> appended to the identity URL with a value
matching one of the possibilities below:
        </p>
        <dl>
          <dt><code>query</code></dt>
          <dd>
Performs a query on the identity given a JSON-LD Frame in the POST body.
          </dd>
          <dt><code>patch</code></dt>
          <dd>
Applies a JSON Patch document specified in the POST body to the identity.
          </dd>
        </dl>
      </section>

      <section>
        <h2>Reading Data from the Identity</h2>
        <p>
Reading data from an identity is performed via an HTTP POST call with a query
parameter called <code>action</code> appended to the identity URL with a value
matching <code>read</code>.
        </p>
     </section>

      <section>
        <h2>Access Control via HTTP Signatures</h2>
        <p>
There are two mechanisms that allow a 3rd party to read protected information
from an identity. The first is to use a browser-based mechanism that
POSTs a request to an identity, allowing the identity owner to 
interactively decide what data access to allow or disallow. The second is an
HTTP Signature [[!HTTP-SIGNATURES]] based mechanism that allows any authorized
client to access data that has been pre-approved by the entity that controls
access to the identity information.
        </p>
     </section>

       <section>
        <h2>Claims and Endorsements</h2>
        <p>
It is possible for a 3rd party to provide digitally signed assertions to be
stored with an identity. For example, if an individual would like to store
digitally signed credentials verifiying their citizenship information, they
would go through the following process:
        </p>
        <ol>
          <li>Go to a government website and start the verification process.</li>
          <li>Provide their identity URL to the government website.</li>
          <li>The government website would digitally sign a claim and attempt to write it to the provided identity.</li>
          <li>The individual would be provided with a dialog to authorize the write of the information to their identity.</li>
          <li>If the authorization is successful, the digitally signed information is written to the identity and will be returned in future queries for such an endorsement.</li>
        <ol>
      </section>
    </section>

    <section>
      <h1>Compatability with other Identity Mechanisms</h1>
      <p>
This identity mechanism is designed to be compatible with other identity
mechanisms in use today such as OpenID, Facebook Connect, and Firefox ID.
      </p>
      <section>
        <h2>Integration with Mozilla Persona / Firefox ID</h2>
        <p>
The identity mechanism is such that it can be returned in a 
Mozilla Persona or FxID-based login. The assertion returned to the FxID-enabled
website would contain an identity URL which would be compatible with this
specification. This allows both the basic email address to the validated, and
extension information (such as citizenship information, age assertions) to be
discoverable after the login.
        </p>
     </section>


    </section>
  </body> 
</html>

